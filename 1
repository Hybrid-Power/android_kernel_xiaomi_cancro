From 9bb14a7f95887f6c5b7bdd34d19b87aa3171d1d6 Mon Sep 17 00:00:00 2001
From: Pranav Vashi <neobuddy89@gmail.com>
Date: Mon, 9 Nov 2015 16:12:34 -0500
Subject: [PATCH] state_notifier: added new driver for on/off operations

* Doze mode and FB notifiers aren't friendly.
  Introduce state notifier to make things smooth.

Change-Id: I1ddf6d0c50f1b5f543d75f546030bc705c722843
Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
---
 drivers/soc/qcom/Kconfig          |   4 +
 drivers/soc/qcom/Makefile         |   1 +
 drivers/soc/qcom/state_notifier.c | 174 ++++++++++++++++++++++++++++++++++++++
 include/linux/state_notifier.h    |  21 +++++
 4 files changed, 200 insertions(+)
 create mode 100644 drivers/soc/qcom/state_notifier.c
 create mode 100644 include/linux/state_notifier.h

diff --git a/drivers/soc/qcom/Kconfig b/drivers/soc/qcom/Kconfig
index bdb897a..ab42bb0 100644
--- a/drivers/soc/qcom/Kconfig
+++ b/drivers/soc/qcom/Kconfig
@@ -643,6 +643,10 @@ config KERNEL_TEXT_MPU_PROT
 	  all masters; Write access is only permited to the
 	  secure world.
 
+config STATE_NOTIFIER
+        bool "State Notifier"
+	default n
+
 source "drivers/soc/qcom/memshare/Kconfig"
 
 source "drivers/soc/qcom/lge/Kconfig"
diff --git a/drivers/soc/qcom/Makefile b/drivers/soc/qcom/Makefile
index 74f7249..041657a 100644
--- a/drivers/soc/qcom/Makefile
+++ b/drivers/soc/qcom/Makefile
@@ -88,3 +88,4 @@ obj-$(CONFIG_MSM_RTB) += msm_rtb-hotplug.o
 obj-$(CONFIG_QCOM_EARLY_RANDOM)	+= early_random.o
 obj-$(CONFIG_MSM_PACMAN)        += msm_pacman.o
 obj-$(CONFIG_MACH_LGE) += lge/
+obj-$(CONFIG_STATE_NOTIFIER)		+= state_notifier.o
diff --git a/drivers/soc/qcom/state_notifier.c b/drivers/soc/qcom/state_notifier.c
new file mode 100644
index 0000000..60383ba
--- /dev/null
+++ b/drivers/soc/qcom/state_notifier.c
@@ -0,0 +1,174 @@
+/*
+ * State Notifier Driver
+ *
+ * Copyright (c) 2013-2015, Pranav Vashi <neobuddy89@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/state_notifier.h>
+#include <linux/notifier.h>
+#include <linux/export.h>
+#include <linux/fb.h>
+#include <linux/module.h>
+
+#define DEFAULT_SUSPEND_DEFER_TIME 	10
+#define DEFAULT_USE_FB_NOTIFIER 	0
+#define STATE_NOTIFIER			"state_notifier"
+
+/*
+ * debug = 1 will print all
+ */
+static unsigned int debug;
+module_param_named(debug_mask, debug, uint, 0644);
+
+#define dprintk(msg...)		\
+do {				\
+	if (debug)		\
+		pr_info(msg);	\
+} while (0)
+
+static struct notifier_block notif;
+static int prev_fb = FB_BLANK_UNBLANK;
+static unsigned int suspend_defer_time = DEFAULT_SUSPEND_DEFER_TIME;
+module_param_named(suspend_defer_time, suspend_defer_time, uint, 0664);
+static struct delayed_work suspend_work;
+static struct workqueue_struct *susp_wq;
+struct work_struct resume_work;
+bool state_suspended;
+module_param_named(state_suspended, state_suspended, bool, 0444);
+static bool suspend_in_progress;
+bool use_fb_notifier = DEFAULT_USE_FB_NOTIFIER;
+module_param_named(use_fb_notifier, use_fb_notifier, bool, 0664);
+
+static BLOCKING_NOTIFIER_HEAD(state_notifier_list);
+
+/**
+ *	state_register_client - register a client notifier
+ *	@nb: notifier block to callback on events
+ */
+int state_register_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&state_notifier_list, nb);
+}
+EXPORT_SYMBOL(state_register_client);
+
+/**
+ *	state_unregister_client - unregister a client notifier
+ *	@nb: notifier block to callback on events
+ */
+int state_unregister_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&state_notifier_list, nb);
+}
+EXPORT_SYMBOL(state_unregister_client);
+
+/**
+ *	state_notifier_call_chain - notify clients on state_events
+ *	@val: Value passed unmodified to notifier function
+ *	@v: pointer passed unmodified to notifier function
+ *
+ */
+int state_notifier_call_chain(unsigned long val, void *v)
+{
+	return blocking_notifier_call_chain(&state_notifier_list, val, v);
+}
+EXPORT_SYMBOL_GPL(state_notifier_call_chain);
+
+static void _suspend_work(struct work_struct *work)
+{
+	state_notifier_call_chain(STATE_NOTIFIER_SUSPEND, NULL);
+	state_suspended = true;
+	suspend_in_progress = false;
+	dprintk("%s: suspend completed.\n", STATE_NOTIFIER);
+}
+
+static void _resume_work(struct work_struct *work)
+{
+	state_notifier_call_chain(STATE_NOTIFIER_ACTIVE, NULL);
+	state_suspended = false;
+	dprintk("%s: resume completed.\n", STATE_NOTIFIER);
+}
+
+void state_suspend(void)
+{
+	dprintk("%s: suspend called.\n", STATE_NOTIFIER);
+	if (state_suspended || suspend_in_progress)
+		return;
+
+	suspend_in_progress = true;
+
+	INIT_DELAYED_WORK(&suspend_work, _suspend_work);
+	queue_delayed_work_on(0, susp_wq, &suspend_work, 
+		msecs_to_jiffies(suspend_defer_time * 1000));
+}
+
+void state_resume(void)
+{
+	dprintk("%s: resume called.\n", STATE_NOTIFIER);
+	flush_workqueue(susp_wq);
+	cancel_delayed_work_sync(&suspend_work);
+	suspend_in_progress = false;
+
+	if (state_suspended)
+		queue_work_on(0, susp_wq, &resume_work);
+}
+
+static int fb_notifier_callback(struct notifier_block *self,
+				unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank;
+
+	if (!use_fb_notifier)
+		return NOTIFY_OK;
+
+	if (evdata && evdata->data && event == FB_EVENT_BLANK) {
+		blank = evdata->data;
+		switch (*blank) {
+			case FB_BLANK_UNBLANK:
+				if (prev_fb == FB_BLANK_POWERDOWN) {
+					state_resume();
+					prev_fb = FB_BLANK_UNBLANK;
+				}
+				break;
+			case FB_BLANK_POWERDOWN:
+				if (prev_fb == FB_BLANK_UNBLANK) {
+					state_suspend();
+					prev_fb = FB_BLANK_POWERDOWN;
+				}
+				break;
+		}
+	}
+	return NOTIFY_OK;
+}
+
+
+static int __init state_notifier_init(void)
+{
+	int ret;
+
+	notif.notifier_call = fb_notifier_callback;
+	ret = fb_register_client(&notif);
+	if (ret)
+		pr_err("Failed to register FB notifier callback for state notifier.\n");
+
+	susp_wq =
+	    alloc_workqueue("state_susp_wq", WQ_FREEZABLE, 0);
+	if (!susp_wq)
+		pr_err("State Notifier failed to allocate suspend workqueue\n");
+
+	INIT_DELAYED_WORK(&suspend_work, _suspend_work);
+	INIT_WORK(&resume_work, _resume_work);
+
+	return ret;
+}
+
+late_initcall(state_notifier_init);
+
+MODULE_AUTHOR("Pranav Vashi <neobuddy89@gmail.com>");
+MODULE_DESCRIPTION("State Notifier Driver");
+MODULE_LICENSE("GPLv2");
diff --git a/include/linux/state_notifier.h b/include/linux/state_notifier.h
new file mode 100644
index 0000000..f25d3b3
--- /dev/null
+++ b/include/linux/state_notifier.h
@@ -0,0 +1,21 @@
+#ifndef __LINUX_STATE_NOTIFIER_H
+#define __LINUX_STATE_NOTIFIER_H
+
+#include <linux/notifier.h>
+
+#define STATE_NOTIFIER_ACTIVE		0x01
+#define STATE_NOTIFIER_SUSPEND		0x02
+
+struct state_event {
+	void *data;
+};
+
+extern bool state_suspended;
+extern bool use_fb_notifier;
+extern void state_suspend(void);
+extern void state_resume(void);
+int state_register_client(struct notifier_block *nb);
+int state_unregister_client(struct notifier_block *nb);
+int state_notifier_call_chain(unsigned long val, void *v);
+
+#endif /* _LINUX_STATE_NOTIFIER_H */
