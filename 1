From c2ef3bcafe6e029f393b8b8a3843d24fcce5c2f0 Mon Sep 17 00:00:00 2001
From: franciscofranco <franciscofranco.1990@gmail.com>
Date: Tue, 1 Jul 2014 00:26:36 +0000
Subject: [PATCH] sound: add sound control to increase headphones, speaker and
 mic gain.

Signed-off-by: franciscofranco <franciscofranco.1990@gmail.com>

sound: wcd9320: tidy up things a little bit. Only accept signed values from now on. The 'headset gain' will only be used to remove some gain noise, increasing it beyond 1 step above the default doesn't make a difference so rather just have it decrease the gain.

Signed-off-by: franciscofranco <franciscofranco.1990@gmail.com>

sound: wcd9320: implement separate locks to prevent derps

* playback, speaker and record locks only to the changed
register values, we don't need the locks to go through other
registers
* this fixes a bug where a user adjusted the headphones gain
and speaker and/or mic would stop working because the lock was
enabled and the switch case would return earlier than it should
* qualcomm, up yours

Change-Id: I81f6f152f9d4449e9d19568ed3879d510189a709
Signed-off-by: franciscofranco <franciscofranco.1990@gmail.com>
---
 drivers/misc/Makefile        |   1 +
 drivers/misc/sound_control.c | 177 +++++++++++++++++++++++++++++++++++++++++++
 sound/soc/codecs/wcd9320.c   | 118 ++++++++++++++++++++++++++++-
 3 files changed, 295 insertions(+), 1 deletion(-)
 create mode 100644 drivers/misc/sound_control.c

diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 8aaf631..e2d0ae1c 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -73,3 +73,4 @@ obj-$(CONFIG_QPNP_MISC) += qpnp-misc.o
 obj-$(CONFIG_STM32_FW_UPDATER) += stm32fwu.o
 stm32fwu-objs := stm32-fwu-i2c.o stm32-bootloader.o
 obj-$(CONFIG_UID_CPUTIME) 	+= uid_cputime.o
+obj-y				+= sound_control.o
diff --git a/drivers/misc/sound_control.c b/drivers/misc/sound_control.c
new file mode 100644
index 0000000..9930ed0
--- /dev/null
+++ b/drivers/misc/sound_control.c
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2014 Francisco Franco
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+
+extern void update_headphones_volume_boost(int vol_boost);
+extern void update_speaker_gain(int vol_boost);
+extern void update_mic_gain(int vol_boost);
+
+/*
+ * Volume boost value
+ */
+int headphones_boost = 0;
+int headphones_boost_limit = 20;
+int headphones_boost_limit_min = -20;
+
+/*
+ * Speaker boost value
+ */
+int speaker_boost = 0;
+int speaker_boost_limit = 20;
+int speaker_boost_limit_min = -20;
+
+/*
+ * Mic boost value
+ */
+int mic_boost = 0;
+int mic_boost_limit = 20;
+int mic_boost_limit_min = -20;
+
+/*
+ * Sysfs get/set entries
+ */
+
+static ssize_t headphones_boost_show(struct device *dev, 
+		struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", headphones_boost);
+}
+
+static ssize_t headphones_boost_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+    int new_val;
+
+	sscanf(buf, "%d", &new_val);
+
+	if (new_val != headphones_boost) {
+		if (new_val <= headphones_boost_limit_min)
+			new_val = headphones_boost_limit_min;
+
+		else if (new_val >= headphones_boost_limit)
+			new_val = headphones_boost_limit;
+
+		pr_info("New headphones_boost: %d\n", new_val);
+
+		headphones_boost = new_val;
+		update_headphones_volume_boost(headphones_boost);
+	}
+
+    return size;
+}
+
+static ssize_t speaker_boost_show(struct device *dev, 
+		struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", speaker_boost);
+}
+
+static ssize_t speaker_boost_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+    int new_val;
+
+	sscanf(buf, "%d", &new_val);
+
+	if (new_val != speaker_boost) {
+		if (new_val <= speaker_boost_limit_min)
+			new_val = speaker_boost_limit_min;
+
+		else if (new_val >= speaker_boost_limit)
+			new_val = speaker_boost_limit;
+
+		pr_info("New speaker_boost: %d\n", new_val);
+
+		speaker_boost = new_val;
+		update_speaker_gain(speaker_boost);
+	}
+
+    return size;
+}
+
+static ssize_t mic_boost_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", mic_boost);
+}
+
+static ssize_t mic_boost_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+    int new_val;
+
+	sscanf(buf, "%d", &new_val);
+
+	if (new_val != mic_boost) {
+		if (new_val <= mic_boost_limit_min)
+			new_val = mic_boost_limit_min;
+
+		else if (new_val >= mic_boost_limit)
+			new_val = mic_boost_limit;
+
+		pr_info("New mic_boost: %d\n", new_val);
+
+		mic_boost = new_val;
+		update_mic_gain(mic_boost);
+	}
+
+    return size;
+}
+
+static DEVICE_ATTR(volume_boost, 0664, headphones_boost_show, 
+	headphones_boost_store);
+static DEVICE_ATTR(speaker_boost, 0664, speaker_boost_show, 
+	speaker_boost_store);
+static DEVICE_ATTR(mic_boost, 0664, mic_boost_show, mic_boost_store);
+
+static struct attribute *soundcontrol_attributes[] =
+{
+	&dev_attr_volume_boost.attr,
+	&dev_attr_speaker_boost.attr,
+	&dev_attr_mic_boost.attr,
+	NULL
+};
+
+static struct attribute_group soundcontrol_group =
+{
+	.attrs  = soundcontrol_attributes,
+};
+
+static struct miscdevice soundcontrol_device =
+{
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "soundcontrol",
+};
+
+static int __init soundcontrol_init(void)
+{
+    int ret;
+
+    pr_info("%s misc_register(%s)\n", __FUNCTION__, soundcontrol_device.name);
+
+    ret = misc_register(&soundcontrol_device);
+
+    if (ret) {
+	    pr_err("%s misc_register(%s) fail\n", __FUNCTION__, 
+	    	soundcontrol_device.name);
+	    return 1;
+	}
+
+	if (sysfs_create_group(&soundcontrol_device.this_device->kobj, 
+    		&soundcontrol_group) < 0) {
+	    pr_err("%s sysfs_create_group fail\n", __FUNCTION__);
+	    pr_err("Failed to create sysfs group for device (%s)!\n", 
+	    	soundcontrol_device.name);
+	}
+
+    return 0;
+}
+late_initcall(soundcontrol_init);
diff --git a/sound/soc/codecs/wcd9320.c b/sound/soc/codecs/wcd9320.c
index 01f2214..b8202d0 100644
--- a/sound/soc/codecs/wcd9320.c
+++ b/sound/soc/codecs/wcd9320.c
@@ -51,6 +51,20 @@
 #include "tpa6130a2.h"
 #endif
 
+struct sound_control {
+	int default_headphones_value;
+	int default_speaker_value;
+	int default_mic_value;
+	struct snd_soc_codec *snd_control_codec;
+	bool playback_lock;
+	bool speaker_lock;
+	bool recording_lock;
+} soundcontrol = {
+	.playback_lock = false,
+	.speaker_lock = false,
+	.recording_lock = false,
+};
+
 #define TAIKO_MAD_SLIMBUS_TX_PORT 12
 #define TAIKO_MAD_AUDIO_FIRMWARE_PATH "wcd9320/wcd9320_mad_audio.bin"
 #define TAIKO_VALIDATE_RX_SBPORT_RANGE(port) ((port >= 16) && (port <= 22))
@@ -4419,9 +4433,35 @@ static int taiko_volatile(struct snd_soc_codec *ssc, unsigned int reg)
 	return 0;
 }
 
+static int reg_access(unsigned int reg)
+{
+	int ret = 1;
+
+	switch (reg) {
+		case TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL:
+		case TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL:
+			if (soundcontrol.playback_lock)
+                                ret = 0;
+                        break;
+		case TAIKO_A_CDC_RX3_VOL_CTL_B2_CTL:
+			if (soundcontrol.speaker_lock)
+                                ret = 0;
+			break;
+		case TAIKO_A_CDC_TX3_VOL_CTL_GAIN:
+			if (soundcontrol.recording_lock)
+				ret = 0;
+			break;
+		default:
+			break;
+		}
+
+	return ret;
+}
+
 static int taiko_write(struct snd_soc_codec *codec, unsigned int reg,
 	unsigned int value)
 {
+	int val;
 	int ret;
 	struct wcd9xxx *wcd9xxx = codec->control_data;
 
@@ -4437,8 +4477,14 @@ static int taiko_write(struct snd_soc_codec *codec, unsigned int reg,
 				reg, ret);
 	}
 
-	return wcd9xxx_reg_write(&wcd9xxx->core_res, reg, value);
+	if (!reg_access(reg))
+		val = wcd9xxx_reg_read(&wcd9xxx->core_res, reg);
+	else
+		val = value;
+
+	return wcd9xxx_reg_write(&wcd9xxx->core_res, reg, val);
 }
+
 static unsigned int taiko_read(struct snd_soc_codec *codec,
 				unsigned int reg)
 {
@@ -7163,6 +7209,63 @@ static struct regulator *taiko_codec_find_regulator(struct snd_soc_codec *codec,
 	return NULL;
 }
 
+void update_headphones_volume_boost(unsigned int vol_boost)
+{
+	int default_val = soundcontrol.default_headphones_value;
+	int boosted_val = default_val + vol_boost;
+
+	pr_info("Sound Control: Headphones default value %d\n", default_val);
+
+	soundcontrol.playback_lock = false;
+	taiko_write(soundcontrol.snd_control_codec,
+		TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL, boosted_val);
+	taiko_write(soundcontrol.snd_control_codec,
+		TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL, boosted_val);
+	soundcontrol.playback_lock = true;
+
+	pr_info("Sound Control: Boosted Headphones RX1 value %d\n",
+		taiko_read(soundcontrol.snd_control_codec,
+		TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL));
+
+	pr_info("Sound Control: Boosted Headphones RX2 value %d\n",
+		taiko_read(soundcontrol.snd_control_codec,
+		TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL));
+}
+
+void update_speaker_gain(int vol_boost)
+{
+	int default_val = soundcontrol.default_speaker_value;
+	int boosted_val = default_val + vol_boost;
+
+	pr_info("Sound Control: Speaker default value %d\n", default_val);
+
+	soundcontrol.speaker_lock = false;
+	taiko_write(soundcontrol.snd_control_codec,
+		TAIKO_A_CDC_RX3_VOL_CTL_B2_CTL, boosted_val);
+	soundcontrol.speaker_lock = true;
+
+	pr_info("Sound Control: Boosted Speaker RX3 value %d\n",
+		taiko_read(soundcontrol.snd_control_codec,
+		TAIKO_A_CDC_RX3_VOL_CTL_B2_CTL));
+}
+
+void update_mic_gain(unsigned int vol_boost)
+{
+	int default_val = soundcontrol.default_mic_value;
+	int boosted_val = default_val + vol_boost;
+
+	pr_info("Sound Control: Mic default value %d\n", default_val);
+
+	soundcontrol.recording_lock = false;
+	taiko_write(soundcontrol.snd_control_codec,
+		TAIKO_A_CDC_TX3_VOL_CTL_GAIN, boosted_val);
+	soundcontrol.recording_lock = true;
+
+	pr_info("Sound Control: Boosted Mic value %d\n",
+		taiko_read(soundcontrol.snd_control_codec,
+		TAIKO_A_CDC_TX3_VOL_CTL_GAIN));
+}
+
 static int taiko_codec_probe(struct snd_soc_codec *codec)
 {
 	struct wcd9xxx *control;
@@ -7176,6 +7279,8 @@ static int taiko_codec_probe(struct snd_soc_codec *codec)
 	struct wcd9xxx *core = dev_get_drvdata(codec->dev->parent);
 	struct wcd9xxx_core_resource *core_res;
 
+	soundcontrol.snd_control_codec = codec;
+
 	codec->control_data = dev_get_drvdata(codec->dev->parent);
 	control = codec->control_data;
 
@@ -7377,6 +7482,17 @@ static int taiko_codec_probe(struct snd_soc_codec *codec)
 	mutex_unlock(&dapm->codec->mutex);
 
 	codec->ignore_pmdown_time = 1;
+
+	/*
+	 * Get the default values during probe
+	 */
+	soundcontrol.default_headphones_value = taiko_read(codec,
+		TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL);
+	soundcontrol.default_speaker_value = taiko_read(codec,
+		TAIKO_A_CDC_RX3_VOL_CTL_B2_CTL);
+	soundcontrol.default_mic_value = taiko_read(codec,
+		TAIKO_A_CDC_TX3_VOL_CTL_GAIN);
+
 	return ret;
 
 err_irq:
